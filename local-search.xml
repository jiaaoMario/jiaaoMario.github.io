<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>协同文档基础：OT架构</title>
    <link href="/2022/10/23/%E5%8D%8F%E5%90%8C%E6%96%87%E6%A1%A3%E5%9F%BA%E7%A1%80%EF%BC%9AOT%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/10/23/%E5%8D%8F%E5%90%8C%E6%96%87%E6%A1%A3%E5%9F%BA%E7%A1%80%EF%BC%9AOT%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="协同文档的前世今生"><a href="#协同文档的前世今生" class="headerlink" title="协同文档的前世今生"></a>协同文档的前世今生</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>探究yarn中pnp模式</title>
    <link href="/2022/09/20/%E6%8E%A2%E7%A9%B6yarn%E4%B8%ADpnp%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/20/%E6%8E%A2%E7%A9%B6yarn%E4%B8%ADpnp%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>随着前端生态链的快速发展，尤其是 Node 的诞生，前端包管理器逐渐成为了我们日常开发中必不可少的工具。回忆一下，可能大多数人第一个接触包管理器应该是 Npm 吧，随着开发场景的增加，npm 已经不再可以满足我们，这时候 yarn 便出现在了我们的面前。yarn 提供了 workspace 等能力。然而，无论是 npm 还是 yarn，对于依赖的管理都存在很大的问题：</p><img src="/2022/09/20/%E6%8E%A2%E7%A9%B6yarn%E4%B8%ADpnp%E6%A8%A1%E5%BC%8F/heaviest-objects-in-the-universe.jpeg" class="" title="heaviest-objects-in-the-universe">]]></content>
    
    
    
    <tags>
      
      <tag>yarn</tag>
      
      <tag>PnP模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协同文档中的光标与选区</title>
    <link href="/2022/09/12/%E5%8D%8F%E5%90%8C%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%85%89%E6%A0%87%E4%B8%8E%E9%80%89%E5%8C%BA/"/>
    <url>/2022/09/12/%E5%8D%8F%E5%90%8C%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%85%89%E6%A0%87%E4%B8%8E%E9%80%89%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>最近正在做公司协同文档的重构开发工作，上一次做富文本开发已经是两年多前了，因此像选区与光标这一类富文本开发核心场景而又有些繁杂的知识点，已经隐约的有些模糊了。正好趁着中秋假期的闲暇时光，希望温故而知新。</p><p>在我司新架构的协同文档中，为了解决系统光标的局限性，采用了模拟光标的架构实现，这类场景专业性较强，就不在本文中赘述了，本文我们将重点讨论的是在可编辑组件以及<code>contentEditable</code>下的光标与选区操作。</p><h2 id="可编辑组件场景下的操作"><a href="#可编辑组件场景下的操作" class="headerlink" title="可编辑组件场景下的操作"></a>可编辑组件场景下的操作</h2>]]></content>
    
    
    
    <tags>
      
      <tag>富文本编辑器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用Normalizr格式化你的数据</title>
    <link href="/2022/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Normalizr%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Normalizr%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BD%A0%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="我们为何选择-Normalizr"><a href="#我们为何选择-Normalizr" class="headerlink" title="我们为何选择 Normalizr"></a>我们为何选择 Normalizr</h2><p>作为前端开发，我们难免经常会和复杂甚至混乱的接口数据结构打交道。这个现象在 ToB 端项目开发中尤为明显。虽然在开发阶段，前后端可以共同决定接口的数据结构，但往往实际情况是，即使约定好了固定的数据结构，依然无法完全满足前端的业务或数据逻辑。这并不是前后端任何一方的问题，而是前后端的开发角度不同，并且过于复杂的业务靠固定的数据结构是无法支撑的。</p><p>在之前遇到这种问题，前端往往是通过复杂的遍历、合并、分离的操作，将接口返回的数据加工成为符合预期的数据类型。这样做确实可以解决问题。但就像上面提到的，在 toB 端可能会有数以百计的接口。如果还是通过这样的方式去格式化，抛开带来的心智负担不说，业务逻辑中嵌入高度耦合的格式化代码会使项目日渐臃肿，更可怕的是，往后在迭代中，当接口发生结构性变动，很有可能对应前端的格式化代码也要重新进行开发！</p><p>这时候便轮到主角出现了，它就是 Normalizr。</p><h2 id="Normalizr-可以为我们带来什么"><a href="#Normalizr-可以为我们带来什么" class="headerlink" title="Normalizr 可以为我们带来什么"></a>Normalizr 可以为我们带来什么</h2><p>Normalizr 的出现解决了上述问题。我们通过简单的方式规定数据模型并交付给 Normalizr，Normalizr 在其内部使用了一些“魔法”后，将规范好的数据返回给了我们。很明显，这一流程使得我们不再需要将注意力放在如何对接口数据进行加工处理上，而是直接拿到了符合预期的数据，就像是接口直接返回的一样。</p><h2 id="Talk-is-cheap-Show-me-your-code"><a href="#Talk-is-cheap-Show-me-your-code" class="headerlink" title="Talk is cheap. Show me your code"></a>Talk is cheap. Show me your code</h2><p>上面花费了一些时间介绍了 Normalizr 的使用背景，接下来废话少说，我们通过一个数据向你展示 Normalizr 的强大能力。</p><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>设想一下，你正在开发一个 Wiki 页面组评论的功能。因为业务逻辑是要基于整个页面组所有页面的评论进行处理，因此后台提供了一个包含所有页面的所有评论列表接口。</p><blockquote><p>该例子目的是创建一个极为极端的背景用于举例，我相信现实中肯定也存在这类需求，但我更建议你可以勇敢的去和 PM Battle，因为即使 Normalizr 的魔法可以帮助你高性能，简单的格式化数据。但这也并不是对性能无损耗的。</p></blockquote><p>抛去一些无关字段，其关键的数据结构大致如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;pages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xjasfashfqweqw&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;uuid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;232912762&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jiaao.mario&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hello Normalizr&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;comments&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;aasjwqeiasiod&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;comment_user_info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;uuid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;11279312&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;user_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bob&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;page_count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">391</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>为了便于后面的演示，作者通过 Mock 工具将上面的模型构建出来一个真实的数据。</p><blockquote><p>关于演示数据的构造，现社区内已经有了大量的 Mock 工具去构建，如<code>mock.js</code>、<code>moco-runner</code>等等。作者使用的是一个在线的 Mock 工具，规则简单，推荐给你：<a href="https://json-generator.com/">json-generator</a></p></blockquote><p>好了，不管使用了什么方式，此时我们已经有了接口的返回数据，接下来我们就可以专心根据需求进行开发工作了。</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景 1"></a>场景 1</h3><p>首先迎来第一个需求：获取所有 page 的作者 id。</p><p>这个需求通过自定义格式化实现起来并不复杂，我们只需要一次的循环便可以获取到所有 page 的作者 id：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> result = data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.<span class="hljs-property">author</span>.<span class="hljs-property">uuid</span>);<br></code></pre></td></tr></table></figure><p>我们也可以使用 Normalizr 进行处理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>normalizr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探究 git-flow</title>
    <link href="/2022/08/03/%E6%8E%A2%E7%A9%B6-git-flow/"/>
    <url>/2022/08/03/%E6%8E%A2%E7%A9%B6-git-flow/</url>
    
    <content type="html"><![CDATA[<p>版本控制工具: git 想必每一个开发者在日常的工作中都会接触到。我们在项目中可以使用 git 进行不同迭代、不同版本的协同开发工作。虽然 git 的能力足以使我们游刃有余的管理大型项目了，但是随着业务的发展，需求的快速迭代，意味着参与项目的开发团队会越来越庞大，这时候就需要在团队中规范一种硬性的分支管理模式，我们可以在团队内约定，也可以使用社区中被多次实践验证过的规范，git-flow 就是其中之一。接下来，我们会探究其具体的管理规范和流程。</p><h2 id="什么是-git-flow"><a href="#什么是-git-flow" class="headerlink" title="什么是 git-flow"></a>什么是 git-flow</h2><p>在开篇中，我们对 git-flow 有了一个大致的认识：“一个基于 git 的版本流程规范”。因此，git-flow 并非另开炉灶，意图取代 git，而是对 git 命令进行了更多的扩展，这些扩展其实是根据 git-flow 的开发模式，将一系列的 git 操作进行了组合，我们在开发过程中，仅需要记住简单的扩展命令，就可以交给 git-flow 进行一系列的 git 执行操作。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 Mac 平台上，有多种方式支持全局安装 git-flow，例如 brew、curl 等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install git-flow<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -L -O https://raw.github.com/nvie/gitflow/develop/contrib/gitflow-installer.sh<br>sudo bash gitflow-installer.sh<br></code></pre></td></tr></table></figure><p>其他环境安装可见：<a href="https://github.com/nvie/gitflow/wiki/Installation">https://github.com/nvie/gitflow/wiki/Installation</a></p><h2 id="git-flow-的管理策略"><a href="#git-flow-的管理策略" class="headerlink" title="git-flow 的管理策略"></a>git-flow 的管理策略</h2><p>git-flow 模式预设了 master 以及 develop 两个长期分支，这与大多数项目中的分支管理策略一致。这两个分支是 git-flow 版本控制过程中最重要的基础分支。</p><ul><li>master 分支作为一个保护性分支，永远与线上运行的代码保持一致。在 master 分支上，任何操作都无法直接进行。</li><li>develop 分支将会是每一个 feature 功能分支的源分支。develop 分支将会汇总所有已完成的 feature 分支并最终和入到 master 分支上。</li></ul><h3 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h3><h4 id="1-开始一个-Feature"><a href="#1-开始一个-Feature" class="headerlink" title="1. 开始一个 Feature"></a>1. 开始一个 Feature</h4><p>在日常开发迭代中，经常会开发新的功能。而在上面我们了解到，git-flow 固定基础分支中，我们通常会从 develop 分支中拉取一个迭代 feature 分支，后续的开发均会在这个迭代分支中进行。</p><p>例如我们准备开发一个迭代名为 B1020，git-flow 首先会帮助我们以 develop 分支为基分支，创建一个名为 feature&#x2F;B1020 的新分支并切换到这个分支上，后续的迭代一直在该分支进行即可。</p><p>上述步骤对应的 git-flow 命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git flow feature start B1020<br></code></pre></td></tr></table></figure><h4 id="2-完成一个-Feature"><a href="#2-完成一个-Feature" class="headerlink" title="2. 完成一个 Feature"></a>2. 完成一个 Feature</h4><p>当我们在 Feature 分支上完成了功能开发工作，此时 Feature 分支便完成了他的任务，即将退出项目管理的声明周期。上面介绍有介绍到，<strong>develop 分支是用于汇总所有已完成的 feature 分支</strong>。我们此时便可以：</p><ol><li>将 Feature 分支合入到 develop 分支中，</li><li>删除迭代分支</li><li>切换当前分支为 develop。</li></ol><p>后续的测试、集成测试等，便可以在 develop 分支中进行，并且大型的项目，往往同时会进行多个迭代的开发工作，因此，develop 在一定时间内，可能会存在多个活跃迭代的场景，可以在所有迭代完成测试后，由 develop 分支为基础进行下一步的发布工作。</p><p>上述步骤对应的 git-flow 命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git flow feature finish B1020<br></code></pre></td></tr></table></figure><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h3><h4 id="预上线分支"><a href="#预上线分支" class="headerlink" title="预上线分支"></a>预上线分支</h4><p>当所有正在进行中的迭代在 develop 分支上已经完成了测试、bugFix、codeReview，已经达到上线标准时，我们便可以生成一个 release 版本，在软件的声明周期中，这样的行为往往意味着创建一个新的 version，因此我们常常使用版本号来对 release 进行命名。release 分支将从 develop 分支中切出类似于<code>release/1.0.1</code>的新分支，我们可以视该分支为一个预上线分支。</p><p>上述步骤对应的 git-flow 命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git flow release start 1.0.1<br></code></pre></td></tr></table></figure><h4 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h4><p>在上面的步骤中，我们创建了一个<code>release/1.0.1</code>的预上线分支。在进行确认以及小幅度调整后，便可以进行真正的发布工作。在 release 发布的过程中，我们需要：</p><ol><li>拉取 origin 分支，确认本地已经是最新、代码最完整的版本。</li><li>将 release 分支同步至 master、develop 这两个基本分支中。这样做的目的是，develop 分支在后续会继续切出迭代分支，这样可以确保后续的迭代分支拥有最新的功能。而 master 分支与线上稳定代码完全一致的分支，因此需要将上线 release 同步。</li><li>为便于识别和做历史参考，release 提交会被标记上这个 release 的名字。</li><li>删除 release 分支，并且切换分支至 develop，以便继续后续的迭代工作。</li></ol><p>上述步骤对应的 git-flow 命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git flow release finish 1.0.1<br></code></pre></td></tr></table></figure><h3 id="Hotfix"><a href="#Hotfix" class="headerlink" title="Hotfix"></a>Hotfix</h3><p>Bug 是每一个程序员的敌人，即使再壮健的系统，bug 也有可能随时随地的出现。这是无法避免的，但我们可以通过版本控制的方式，将 bug 快速解决，把影响降到最低。</p><h4 id="快速响应"><a href="#快速响应" class="headerlink" title="快速响应"></a>快速响应</h4><p>当我们在线上或者 release 预发布中遇到 bug 时，为了快速解决问题，我们可以以 master 为基本分支切出一个 hotfix 分支，如解决 uc 权限问题：<strong>fix-uc-permission</strong>，便可以切出一个 hotfix&#x2F;fix-uc-permission 对问题进行修复。</p><p>上述步骤对应的 git-flow 命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git flow hotfix start fix-uc-permission<br></code></pre></td></tr></table></figure><h4 id="完成-hotfix"><a href="#完成-hotfix" class="headerlink" title="完成 hotfix"></a>完成 hotfix</h4><p>当完成了对 bug 的修复工作，接下来就涉及 bugfix 流程的上线行为了。因为 hotfix 可以视为一次补丁和发布，因此行为和 release 发布类似:</p><ol><li>将涉及改动同步至 master 与 develop，其目的和 release 发布时同步是一致的。</li><li>hotfix 提交会被标记上这个 hotfix 的名字。</li><li>删除 hotfix 分支，切换当前分支为 develop。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 git-flow 的版本控制的核心思想，其实思考一下，也许有很多的团队虽然没有使用 git-flow 进行开发管理，但基本思想是和 git-flow 有异曲同工之妙的。git-flow 的存在只是为了将成熟的开发管理模式进行了集成式包装。甚至我们可以以 git-flow 作为一个 submodule 进行二次封装，来实现一个更适合团队特定需求的版本开发管理工具。</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>git-flow</tag>
      
      <tag>项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>古早前端程序员是如何构建项目的</title>
    <link href="/2022/07/28/%E5%8F%A4%E6%97%A9%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84/"/>
    <url>/2022/07/28/%E5%8F%A4%E6%97%A9%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p>回想一下自己的代码生涯，大一开始接触前端，每天跟着 HTML、CSS、JavaScript 死磕。那时候，以为一个个<code>&lt;script&gt;&lt;/script&gt;</code>就是全世界。然而在接触到前端三大件、各类模块构建工具后，仿佛发现了新大陆，原来前端也可以玩的如此花样百出，回头就将那一个个 script 打入了冷宫。转眼间，步入社会已经数载，一切都还顺利，从事着前端开发的工作，也算大学时的付出没有白费。近日闲来无事，在 github 上逛逛仓库，发现了已经停止维护的 IScroll，看着作者将近十年前的 commit 和古典的代码风格，仿佛一下子回到了自己的大学时代。感叹代码可以改变我们的生活，也可以记录我们的青春的同时，也勾起了我对于其源码和构建方式的兴趣，故写此文章，本文主要讨论的是在没有 Webpack 的时代，前端程序员们是如何编写一个庞大的包的。希望本篇文章，可以带你找回那个少年的你。</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>首先，IScroll 已经是十多年前的包了，整个项目全部是以 ES5 为语法进行编写的。在那个没有 Webpack、Gulp 等现代模块打包工具的年代里，我们对于项目的模块化拆分策略往往是将不同的 script 文件按照依赖顺序进行引入或者直接在一个文件中进行编写，这样的开发模式带来的问题显而易见：要么牺牲了项目的模块化，要么 script 一个个按需的引用顺序带来了不小的心智负担。而 IScroll 的模块化拆分使我眼前一亮。</p><h2 id="build-js"><a href="#build-js" class="headerlink" title="build.js"></a>build.js</h2><p>IScroll 的构建脚本位于根目录的 build.js 中，脚本依赖的第三方包很清晰：</p><ul><li>jshint 在 eslint 之前是最流行的代码风格格式化工具。</li><li>uglify-js 现在也很常用的代码混淆工具。</li></ul><p>build 脚本的开始，IScroll 通过读取命令行参数来获取构建目标。不同模式的 IScroll 可能依赖的内容是不同的。因此在这一步，IScroll 便可以分析出本次构建需要依赖的具体文件。IScroll 主要的构建行为位于 build 函数中，首先 IScroll 定义了一个文件执行栈，栈内的文件会依次弹出进行读取操作。具体代码可见下面的代码片段：</p><img src="/2022/07/28/%E5%8F%A4%E6%97%A9%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84/files_strack.png" class="" title="files_strack"><p>我们把重点放在 open.js 以及 close.js 上，代码很简单，相信有一定模块化开发经验的同学会一眼看出，这是要构建一个 IFEE 私有模块，而在这两个文件中间的文件，则会被定义在这个私有模块下。这样的方式可以为 IScroll 内部变量和方法创建出一个私有化的 namespace，防止全局污染。</p><img src="/2022/07/28/%E5%8F%A4%E6%97%A9%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84/open.png" class="" title="open"><img src="/2022/07/28/%E5%8F%A4%E6%97%A9%E5%89%8D%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%9A%84/close.png" class="" title="close"><p>在确认了文件打包的上下组成和注入顺序后，我们便可以进行文件读取拼接操作。首先在 build 文件的最开始，作者通过版本号等信息，拼接出了一段版权和包版本信息，拼接到了最先读取的文件的顶部。仔细想想，这和我们在使用 Webpack 的过程中，使用 <code>webpack.BannerPlugin</code>插件注入头信息有异曲同工之妙。</p><p>当我们将文件栈中的文件依次读取拼接后，接着进行下一步，占位符的替换和定点插入。因为 IScroll 将一些独立的功能模块拆分为了不同的文件，IScroll 便通过读取配置项，获取占位符的方式，实现插件模块的引入和占位符替换为变量。</p><p>执行到这里，我们已经拿到了完整的内容，这时便可以使用写文件的操作写入 out 目录中。后续还可以进行一系列的操作，如使用 jsHint 进行代码风格校验，使用 uglify-js 对先前拼接的文件内容进行混淆压缩写入到另外的 dist 目录中，自此，便完成了 IScroll 的构建工作。</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>即使是像 IScroll 一类的已经停止维护的项目，在阅读前辈们的代码过程中，还是能够收获很多：</p><ol><li>JavaScript 的模块化发展进程，在现在的模块构建工具诞生之前，我们可以如何组织项目的结构并进行构建。</li><li>从 IScroll 的构建思想，延伸至 Webpack 中，可以发现，Iscroll 和 Webpack 无论是关注 entry，output 的处理流程，还是对代码插入点的处理方式，都有一些类似的地方。也正是一批批前辈的实践，才给现在的前端生态提供了无数多的可能。</li></ol><p>最后用一首诗结束本篇文章吧：</p><blockquote><p>今人不见古时月，今月曾经照古人。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>人类高质量npm包赏析</tag>
      
      <tag>IScroll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人类高质量npm包赏析之react-error-boundary</title>
    <link href="/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90%E4%B9%8Breact-error-boundary/"/>
    <url>/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90%E4%B9%8Breact-error-boundary/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>react-error-boundary，就 package 的名字而言便可以猜出，这是一个针对 React UI 级别的的异常处理模块。对于使用命令式编写的代码来说，我们经常会使用 try.catch 进行异常处理和降级:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// do some wrong thing</span><br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>  <span class="hljs-comment">// 进行异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而在 UI 框架的 UI 视图层中，则需要框架底层进行运行时的支持。</p><h2 id="React-的错误边界"><a href="#React-的错误边界" class="headerlink" title="React 的错误边界"></a>React 的错误边界</h2><p>在 React v16 之前，任何组件暴露出的异常，会导致整个应用的崩溃。对于系统来说，错误是无法避免的，因此很显然，一处出错导致系统崩溃是不合理的。因此在 React v16 推出了错误边界[Error Boundaries]这一概念。援引 <a href="https://react.docschina.org/docs/error-boundaries.html">React 官方文档</a> 对于错误边界的定义：</p><blockquote><p>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p></blockquote><p>由此可见，我们可以借助 <code>getDerivedStateFromError</code> 以 <code>componentDidCatch</code>,包装一个 Error Boundaries 组件，从而收集其子组件的异常，并做出降级操作。</p><h2 id="初识-react-error-boundary"><a href="#初识-react-error-boundary" class="headerlink" title="初识 react-error-boundary"></a>初识 react-error-boundary</h2><p>在现在的大型项目中，组件的动态加载已是最常用的体积优化方案之一，React 也是贴心的开放了 React.lazy 方法支持开发者引入异步加载组件。然而 Production Env 的干扰因子总是千奇百怪，如果遇到了网络问题或者模块加载问题导致异步加载的组件资源拉取失败。对于用户来说，操作流程被阻断却无异常反馈，体验感会非常糟糕。而对于开发人员来说，排查起来也是不小的心智负担。</p><p>这时候便可以使用 ErrorBoundaries 组件进行错误的捕获，可以自己实现，也可以直接使用本篇文章要介绍到的主角: React-error-boundary。React-error-boundary 为我们提供了一个完整的错误边界处理方案。</p><h2 id="源码赏析"><a href="#源码赏析" class="headerlink" title="源码赏析"></a>源码赏析</h2><p>react-error-boundary (本文后续简称为 REB)定位是一个 UI 框架层面的错误边界处理方案，因此代码整体上也是较为简单易懂。REB 核心代码位于 <code>src/index.tsx</code> 文件中，使用 TypeScript 进行编写，在开始阅读源码前，我们可以首先通过定义的接口类型大致推测出使用方式和内部结构:</p><p>type ErrorBoundaryProps 汇总了三种 REB 调用方式，分别是 Fallback 调用，Component 高阶函数调用以及插入渲染函数方式调用。</p><img src="/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90%E4%B9%8Breact-error-boundary/ErrorBoundaryProps.png" class="" title="ErrorBoundaryProps"><p>其中，这三类调用方式具有相同的公共 Props：</p><img src="/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90%E4%B9%8Breact-error-boundary/PubicProps.png" class="" title="PubicProps"><p>其中，很好理解的是 onError，当内部函数发生异常错误时，REB 会触发该事件。而另外三个参数，则是围绕着 REB 的错误重试机制配置的，通过配置 resetKey 达到对错误组件的加载重试。</p><p>说完了三种模式的共同点，接下来让我们看下这三种模式从类型声明上看，会有什么不同。</p><img src="/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90%E4%B9%8Breact-error-boundary/DifferentProps.png" class="" title="DifferentProps"><p>当我们将三种方式不同类型抽离出进行对比，可以很明显的看出，其实仅仅是对接收不同 fallback 的处理方式进行的多态处理罢了。在了解了 REB 的接口后，我们已经对 REB 的预计实现有了大致的推测，接下来就让我们带着心里的推测以及疑问，正式开始对 REB 的实现进行研究。</p><h3 id="REM-内部实现"><a href="#REM-内部实现" class="headerlink" title="REM 内部实现"></a>REM 内部实现</h3><p>REM 对外暴露出了<code>ErrorBoundary</code>, <code>withErrorBoundary</code>, <code>useErrorHandler</code>,三个方案。</p><h4 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h4><p>ErrorBoundary 是一个 class component 组件。从 Props 的定义来看在接收我们在上面提到的 ErrorBoundaryProps，此外还使用 PropsWithChildren 声明接收 children，因此 ErrorBoundary 是一个高阶组件。组件内部维护着 state 用于存储当前收集到的 Error，并使用了在第一节中介绍到的 React 错误边界处理钩子：<code>getDerivedStateFromError</code> 及 <code>getDerivedStateFromError</code>。通过 static getDerivedStateFromError 监控子组件的异常问题，如有异常抛出，则返回获取到的异常值存入 state 中。而 getDerivedStateFromError 则在子组件异常抛出时，触发 props 中 onError 方法，用于对外同步状态。到此为止，ErrorBoundary 组件已经实现了最基础的异常检测，但仅仅是这样是不够的，REB 还提供了重试的逻辑。让我们把注意力放到 ErrorBoundary 的 render 函数中，在上文中，我们提到了 ErrorBoundary 内部维护着变量用于存储嵌套组件抛出的异常，而在 render 函数中，便通过这个变量对嵌套组件进行问题降级：变量为空时，正常渲染 props.children，也就是嵌套的子组件，如果变量存储了异常结果，则进行异常的 UI 展示，在先前对接口定义进行分析时，我们已经初步了解到 ErrorBoundary 接收三种模式的 fallback，而实现上印证了我们的猜想，ErrorBoundary 通过对参数的判断，进行节点、渲染函数、组件不同级别策略的渲染，并向其注入 error reason 以及一个 <code>resetErrorBoundary</code> 方法。resetErrorBoundary 内部对 state 初始化，并调用 props 传入的 onReset callback，使得错误的子组件重新进行渲染。</p><h4 id="withErrorBoundary"><a href="#withErrorBoundary" class="headerlink" title="withErrorBoundary"></a>withErrorBoundary</h4><p>REB 同样提供了函数式组件的调用模式，原理很简单，withErrorBoundary 接收待包裹组件以及 ErrorBoundary 需要的 Props 配置项，在内部间接调用 ErrorBoundary 组件即可。</p><h4 id="useErrorHandler"><a href="#useErrorHandler" class="headerlink" title="useErrorHandler"></a>useErrorHandler</h4><p>useErrorHandler 是 REB 配套的一个自定义 hooks，内部实现较为简单。可以通过 useHooks 进行使用，也可以直接作为 Error handler 使用。</p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol><li>REB 是基于 React v16+ 中的错误边界实现的，因此在阅读该源码后，我们可以对错误边界有了更深入的了解，相信看到这里，你也可以轻而易举的实现一个自己的错误边界处理库了。</li><li>REB 是使用 TypeScript 进行开发的库。很多开发者在阅读源码时候，直接直奔源码实现，往往看了半天不知道在看什么，慢慢的也失去了学习的信心和动力。这时候我们先去看核心的类型声明。经验告诉我们，对外暴露出的类型声明往往都是核心的，将它们了解透彻，我们便可以知道源码实现中的条件和目的，这样我们带着推测和问题去阅读源码就清晰简单多了。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>人类高质量npm包赏析</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人类高质量npm包赏析</title>
    <link href="/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90/"/>
    <url>/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>曾有幸与一位业内大佬传道受业解惑，当聊到目前前端社区造轮子的风气时，大佬云淡风轻的说了一句，百分之九十五的人都是在瞎搞，先看完二三十个开源的项目再谈造轮子。</p><img src="/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90/cai.jpeg" class="" title="菜鸡"><p>这句话便深深地刻在那时年幼的我心上，虽然工作几年后，也开源造了一些轮子，但每当技术遇到瓶颈的时候，还是会想起大佬的教导，沉下心来，夯实基础方可成就大业。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://jiaaomario.github.io/2022/07/16/%E4%BA%BA%E7%B1%BB%E9%AB%98%E8%B4%A8%E9%87%8Fnpm%E5%8C%85%E8%B5%8F%E6%9E%90%E4%B9%8Breact-error-boundary">人类高质量 npm 包赏析之 react-error-boundary</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>人类高质量npm包赏析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux源码解析</title>
    <link href="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redux 是最为流行的 JavaScript 状态管理容器之一，其具有单一数据源、状态树数据只读、通过 Reducers 纯函数变更等特性使得运行时状态具有可预测的特性。本篇文章我们将深入 Redux 源码，通过学习其内部实现，从而加深我们对 Redux 的理解，便于未来工作中的更好使用。在阅读本文章前，建议读者对 Redux 有一定的使用经验，如对 Redux 较为陌生，可移步<a href="https://redux.js.org/">redux 官方文档</a>。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>首先，将 Redux 源码拉取至本地，本项目接下来的所有源码分析都会以 Redux 项目为基础。</p><h2 id="2-开始"><a href="#2-开始" class="headerlink" title="2. 开始"></a>2. 开始</h2><p>整体来讲，Redux 源码目录架构是最流行的 JavaScript 包架构。当我们拿到这样一个目录架构后，不需要上来便看代码，可以通过 package.json 对项目不同构建模式声明确认入口。</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/pkg.png" class="" title="package.json"><p>接下来我们将从<code>/src/index.ts</code>作为入口进行学习。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><h3 id="3-1-入口文件-index"><a href="#3-1-入口文件-index" class="headerlink" title="3-1 入口文件 index"></a>3-1 入口文件 index</h3><p>index.ts 文件作为 Redux 架构的出口，其主要功能主要是对外暴露 Redux 核心 api、类型声明以及运行时的环境判断。</p><p>在 index.ts 代码中，可以看到，redux 声明了一个无内部实现的方法：isCrushed，根据函数名便可猜测出，该方法是用来检测当前运行代码是否经过压缩处理。</p><p>原理是：当我们的代码混淆工具对代码进行压缩时，往往会对函数名进行混淆，根据这一背景，我们便可以通过对比函数名和预设函数名字符串，判断是否经过压缩混淆了。</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/isCrushed.png" class="" title="isCrushed"><p>好了，让我们言归正传，在这里主要关注对外暴露的 Redux Apis:</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/export_apis.png" class="" title="index.ts文件中对外暴露的核心api"><h3 id="3-2-createStore"><a href="#3-2-createStore" class="headerlink" title="3-2 createStore"></a>3-2 createStore</h3><p>在 createStore api 中，我们可以创建一个 Redux store 用以存放应用中的全部 state。createStore 的核心实现代码位于<code>/src/createStore.ts</code> 文件中；</p><p>在 TypeScript 项目中，我们可以首先通过函数的类型声明定义进行初步的了解。对 createStore 函数而言，定义了四个函数重载，最大的不同在于每一个重载支持接受不同的参数：分别是：</p><ol><li>reducer：用于处理 state 更新行为的纯函数 Reducer。</li><li>preloadedState：传入的 state 初始化数据。</li><li>enhancer：State Enhancer 是一个可选项，它是一个组合 store creator 的高阶函数，返回一个新的强化过的 store creator。具体实现和使用我们在后续会进行讨论。</li></ol><p>在 createStore 方法体中，由于支持函数的重载，所以在方法的前半段，主要对函数参数进行判断和处理。在数据处理完成后，可以看到，createStore 走向了两个逻辑分支，当 enhancer 参数正常传入的情况下，将 createStore 作为参数传入 Enhancer 进行功能扩展后，返回新的 createStore 再次进行后续的处理：</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/createstore_enhancer.png" class="" title="createstore_enhancer"><p>因为传入的是 Redux 内部定义的 action，因此在进入 Reducer 方法中，最后均会返回 defaultState，实现了 State 的舒适化。</p><p>最后，我们创建 Store 对象，并将 <code>dispatch</code>、<code>subscribe</code>、<code>getState</code>、<code>replaceReducer</code>、<code>$$observable</code> 进行挂载并返回。至此，createStore 内部大致执行流程结束。接下来，我们将注意力放到上面提到的暴露方法以及 createStore 内部重要的功能函数上。</p><h4 id="3-2-1-ensureCanMutateNextListeners"><a href="#3-2-1-ensureCanMutateNextListeners" class="headerlink" title="3-2.1 ensureCanMutateNextListeners"></a>3-2.1 ensureCanMutateNextListeners</h4><p>ensureCanMutateNextListeners 函数的内部实现非常简单，目的在于对监听队列的一次浅复制，从而实现在 subscribe 内部嵌套 subscribe 时，不会出现嵌套订阅方法和外部订阅方法同时触发的问题。</p><h4 id="3-2-2-getState"><a href="#3-2-2-getState" class="headerlink" title="3-2.2 getState"></a>3-2.2 getState</h4><p>正如 getState 方法名，该函数的唯一功能便是用于返回当前的 state。</p><h4 id="3-2-3-subscribe"><a href="#3-2-3-subscribe" class="headerlink" title="3-2.3 subscribe"></a>3-2.3 subscribe</h4><p>subscribe 是一个 Redux 层级的变化监听器，当 dispatch action 时便会执行，并会返回一个解除订阅方法。往往在 Redux 的绑定库中，例如 React-Redux 等等，对 subscribe 的使用很多。</p><p>Redux 中的调度系统是典型的发布订阅模式。在 createStore 中，我们维护了 currentListeners 以及 nextListeners 作为事件监听的存储。在注册和销毁监听函数前，Redux 调用之前提到的 ensureCanMutateNextListeners 方法后，将监听方法存入监听队列中。最后返回 unsubscribe 方法。</p><h5 id="3-2-3-1-unsubscribe"><a href="#3-2-3-1-unsubscribe" class="headerlink" title="3-2.3-1 unsubscribe"></a>3-2.3-1 unsubscribe</h5><p>unsubscribe 用于解除其源 subscribe 中注册的监听函数。</p><h4 id="3-2-4-dispatch"><a href="#3-2-4-dispatch" class="headerlink" title="3-2.4 dispatch"></a>3-2.4 dispatch</h4><p>dispatch 是触发 state 变更的唯一途径，是 Redux 中最常用到的 Api 之一。dispatch 接收一个 action 描述，在 dispath 执行过程中，首先会将全局 isDispatching 锁置为 True，这样，在其他 Redux 方法中，检测到 isDispatching 锁定后，会禁止 state 的读写。接着会将 action 透传至 Reducer 中，进行 state 的变更操作，变更操作完成后，会将 Redux 读写解锁。为了每一次 dispatch 后，subscribe 均会相应，需要将 listeners 中监听函数依次取出并调用，一切操作完成后，返回本次的 action 对象。</p><h4 id="3-2-5-replaceReducer"><a href="#3-2-5-replaceReducer" class="headerlink" title="3-2.5 replaceReducer"></a>3-2.5 replaceReducer</h4><p>replaceReducer 相对其他方法来说比较陌生，虽然在 Store 中暴露出来，但其本身是一个底层的 Redux Api。replaceReducer 的目的是在 createStore 生成 Redux Store 后，替换原有的 Reducer。其内部实现也较为简单，就是之前初始化的 currentReducer 替换为将新传入的 Reducer 方法，这样在后续的 dispatch 中，调用的均是替换后的 newReducer 了。值得注意的是，在 newReducer 替换完成后，Redux 内部手动调用了 dispatch 方法：</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/replaceReducer.png" class="" title="replaceReducer"><p>和上述 Dispatch.INIT 类似，当我们 dispatch 时，对 currentState 进行一次同步作业。最后，replaceReducer 返回已替换过 Reducer 的 Store。</p><h4 id="3-2-6-observable"><a href="#3-2-6-observable" class="headerlink" title="3-2.6 observable"></a>3-2.6 observable</h4><p>随着这里逻辑上很简单，但还是有一些知识点可以进行拓展的，因此卖个关子，敬请期待后续独立的文章解析。</p><h3 id="3-3-compose"><a href="#3-3-compose" class="headerlink" title="3-3 compose"></a>3-3 compose</h3><p>从 TypeScript 类型声明中来看，compose 是一个一或多参数组合的工具函数。用过 lodash 的同学可能使用过 flow 或者 flowRight，flowRight 便是和 compose 相同的操作，接收多个函数，并从右向左依次执行，下一个函数会将上一个函数 return 的数据作为入参处理，直至最后一个函数完成并返回最终结果。让我们回归源码：</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/compose.png" class="" title="compose"><p>Redux 分别对于 0 入参、单独入参、多入参分别进行了不同的逻辑拆分。在多参数的情况下，通过 reduce 对函数进行从右到左的传参和执行，从而实现了类似下面的执行结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(<span class="hljs-title function_">c</span>(<span class="hljs-title function_">d</span>(<span class="hljs-number">1</span>))));<br></code></pre></td></tr></table></figure><h3 id="3-4-combineReducers"><a href="#3-4-combineReducers" class="headerlink" title="3-4 combineReducers"></a>3-4 combineReducers</h3><p>在大型项目中，一个单独的 reducer 函数已经无法承担越来越高的业务复杂程度，因此 Redux 支持使用者根据业务模块将 Reducer 拆分为多个子 reducer，最后使用 combineReducers Api 进行合并为一个完整的 Reducer。</p><p>combineReducers 方法中，接收一个由子 reducer 组成的 map，首先 combineReducers 通过遍历的方式检查每一个 reducer 的类型是否合规，在将合规的 reducer 复制到 finalReducers 上后，会将 finalReducers 作为参数传入至内部的 <code>assertReducerShape</code> 方法中。同样的 assertReducerShape 也是对 reducer 进行合规检查，但 assertReducerShape 检查的重点是，传入的子 reducer 是否按照 Redux 对于 Reducer 的最佳开发标准实现的，即：<strong>传入未匹配到的 Action，返回默认 State、永远不可返回 undefined、如果传入的 state 就是 undefined，一定要返回对应 reducer 的初始 state。</strong>。如果未按照上述标准创建 Reducer，则会在返回的 combination 函数执行时，抛出对应的 Error。</p><p>combineReducers 返回的 combination 函数，其实就是一个整合了所有的子 Reducer 的完整 Reducer。他的参数和 Reducer 一致，区别在于，任意的 Reducer 参数均可传入进行对应的操作。combination 中维护了 <code>hasChanged</code> 及 <code>nextState</code> 作为标志位，hasChanged 的作用是作为数据变更的标志位，nextState 则存储变更后的数据，用于计算 hasChanged。接着，将 Reducers 进行遍历，依次将 state 和 action 传入 reducer 中，返回的新 reducer State 作为新的 State 存储至 nextState。后续可以通过 nextState 中新鲜值，与传入的 state 进行简单对比判断数据是否发生变更，如果 hasChanged 为 True,则返回 Fresh State，否则返回传入的 state。</p><h3 id="3-4-bindActionCreators"><a href="#3-4-bindActionCreators" class="headerlink" title="3-4 bindActionCreators"></a>3-4 bindActionCreators</h3><p>把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。bindActionCreators 常用于不想给予 dispatch 能力但希望对 Redux State 进行变更的场景。首先，Redux 针对单独的 Creator 封装了操作函数：</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/bindActionCreator.png" class="" title="bindActionCreator"><p>bindActionCreator 接收一个 action 生产者，以及 dispatch。在函数体内部返回一个新的函数，函数接收参数可以用于 action 额外的 payload 值，返回值是 dispatch 创建好的 action。由此可见 bindActionCreator 目的明确，并且实现简单。而 bindActionCreators 其实也是通过调用 bindActionCreator 实现的。</p><p>bindActionCreators 同样使用重载，兼容多种传参实现。当传入值为函数时，视为传入了一个 action 创造者，则符合 bindActionCreator 入参，直接交付 bindActionCreator 函数处理即可。</p><p>倘若 actionCreators 为 Map 类型，则视为传入了一组 action Creator，此时，bindActionCreators 会通过<code>for in</code>进行遍历，如果每一个 action Creator 为函数，则依次将 value 与 dispatch 作为参数传入 bindActionCreator 中，并将返回值保存传入时的结构整体返回:</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/bindActionCreators.png" class="" title="bindActionCreators"><h3 id="3-5-applyMiddleware"><a href="#3-5-applyMiddleware" class="headerlink" title="3-5 applyMiddleware"></a>3-5 applyMiddleware</h3><p>在 Redux 中，Middleware 类似 Koa 中的中间件洋葱模型，自定义功能的 middleware 可以在无侵入性的模式下扩展 Redux，并支持多个 Middleware 链式组合。类似于异步 Dispatch 的扩展 redux-thunk，都是采用 applyMiddleware 进行扩展的。applyMiddleware 支持接收一个或多个中间件插件：</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/middlewares.png" class="" title="middlewares"><p>让我们回忆一下，Reudx 源码在 createStore 中，如果传入 enhancer，则会向 enhancer 中传入 createStore，并向 enhancer 返回的函数中传入 reducer、preloadedState，</p><img src="/2022/07/02/Redux%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/enhancer.png" class="" title="createStore中对enhancer的处理逻辑"><p>applyMiddleware 会根据上述这些参数，创建 Store，构造 拥有 getState、dispatch 能力的 middlewareAPI。经过上述的准备工作后，便可以进行 applyMiddleware 核心逻辑，通过对 middlewares 进行遍历，其注入 middlewareAPI 并执行，获取 chains，并通过 compose Api 依次执行 chain 获取最终加密后的值，完成对 Redux Dispath 的扩展。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>到此为止，本篇文章介绍了 Redux 的主要 Api 实现逻辑和原理。贯穿整篇文章，我们深刻的意识到，Redux 的核心思想无非是，通过 Reducer，Action 贯穿单数据流向，并通过 MiddleWares 进行非侵入性的扩展。希望看完本篇文章，可以使您对 Redux 有更深入的了解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redux</tag>
      
      <tag>React</tag>
      
      <tag>源码解析</tag>
      
      <tag>状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大话H5与Native</title>
    <link href="/2022/03/12/%E5%A4%A7%E8%AF%9DH5%E4%B8%8ENative/"/>
    <url>/2022/03/12/%E5%A4%A7%E8%AF%9DH5%E4%B8%8ENative/</url>
    
    <content type="html"><![CDATA[<p>北京的疫情反反复复，至今已喜提两次居家隔离 👨🏻‍💻。好在最近版本迭代已完成，可以抽出时间静下心来做些技术拓展。</p><h2 id="本文你将了解到什么？"><a href="#本文你将了解到什么？" class="headerlink" title="本文你将了解到什么？"></a>本文你将了解到什么？</h2><p>本文将从 hybrid 的基本架构和混合式开发的理论实现入手，通过阅读本文，阁下将有机会通过分析 JockeyJs 的源码从而了解整个 Hybrid 的原理。</p><h2 id="什么是-hybrid"><a href="#什么是-hybrid" class="headerlink" title="什么是 hybrid?"></a>什么是 hybrid?</h2><p>随着移动端设备的大规模普及，Hybrid 已经成为了最主流的快速迭代方案。Hybrid 基于 H5 的灵活的开发模式，例如嵌入 App 内置 webview 组件框架内，加以 Native 提供的部分原生能力，从而给予用户提供可媲美原生 App 的使用体验。我司基金股票交易 App 便是基于该架构进行实践的，并将入金等核心页面使用 Hybrid 实现，运行至今一直稳定并保持了优异的用户体验，可见，在无数个实践中，Hybrid 是值得我们信赖的。</p><h2 id="hybrid-的设计方案"><a href="#hybrid-的设计方案" class="headerlink" title="hybrid 的设计方案"></a>hybrid 的设计方案</h2><ol><li>基于 WebView 容器，通过 JsBridge 实现 H5 与 Native 的交互通讯。</li><li>使用社区内部提供的 Native UI 方案，例如利用 React 在编译时是基于 Virtual DOM 为切入点,传递至 Native 并进行原生渲染。</li><li>小程序方案，例如微信小程序、支付宝小程序。</li></ol><p>我司混合式开发架构采用的是第一种：WebView 容器架构。接下来主要探讨的也主要是这一模式。</p><blockquote><p>古有牛郎织女通过鹊桥相见，你侬我侬。今有 jsbridge 消除 Native 与 H5 隔阂，前端同学抢了 Native 同学的活:)</p></blockquote><p>Native 和 H5 的双向通讯机制是 hybrid 混合式开发核心之处。在 Native 中，不同的系统存在着统一的 webview 内嵌组件。</p><h2 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h2><p>在 IOS 与 Android 中，Webview 内核是不同的。即便在相同的系统中，不同版本的系统，Webview 内核也有可能存在差异。</p><p>例如在低版本 Android 中使用的是 WebKit 内核, 在 Android 高版本中则提供 Chromium 作为系统 WebView 的底层内核支持。</p><p>IOS 最开始使用的为 UIwebView，但 UIwebview 无论是在新特性的支持度上或者页面渲染性能上都不尽如人意，因此后续 IOS 升级为 WKWebView 做为内核。因此随着 Native Webview 内核的升级，提供了更多的功能类，使得无论是用户体验还是功能来讲，都有了很大的提升。</p><h2 id="Jsbridge-与-Native-的通讯原理"><a href="#Jsbridge-与-Native-的通讯原理" class="headerlink" title="Jsbridge 与 Native 的通讯原理"></a>Jsbridge 与 Native 的通讯原理</h2><h3 id="H5-通知-Native"><a href="#H5-通知-Native" class="headerlink" title="H5 通知 Native"></a>H5 通知 Native</h3><ol><li>Api 注入：由于 Native 为 webview 的提供者，因此 Native 同样拥有着获取 JavaScript 环境上下文的超能力，可以通过 webview 提供的方法在 JavaScript 执行环境内挂载全局对象和方案。</li><li>网络请求拦截: webview 提供了协议拦截 API，例如 IOS 上的 shouldStartLoadWithRequest 以及 Android 上的 shouldOverrideUrlLoading。当匹配到特定的拦截请求后，解析意图进行响应。</li><li>特定 jsAPI 拦截： Native 通过拦截 WebView 中 JavaScript 执行的 prompt&#x2F;console&#x2F;alert 操作，解析意图进行响应，但改方式并不稳定。</li></ol><p>目前的主要手段是通过第二种方式：请求拦截实现的，我司也是通过该手段进行业务跨端交互。</p><h3 id="Native-通知-H5"><a href="#Native-通知-H5" class="headerlink" title="Native 通知 H5"></a>Native 通知 H5</h3><p>正如上文所讲，Native 为 H5 提供了宿主容器：webView，并且 webView 也贴心的提供了 API 可以直接接入 JavaScript 运行时，执行 JavaScript 代码逻辑。</p><p>IOS:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">webview.stringByEvaluatingJavaScriptFromString(<span class="hljs-string">&quot;JSBridge.trigger(&#x27;NativeCall&#x27;)&quot;</span>);<br></code></pre></td></tr></table></figure><p>Android:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">webView.loadUrl(<span class="hljs-string">&quot;javascript:JSBridge.trigger(&#x27;NativeCall&#x27;)&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="探究-Jsbridge-的底层实现"><a href="#探究-Jsbridge-的底层实现" class="headerlink" title="探究 Jsbridge 的底层实现"></a>探究 Jsbridge 的底层实现</h2><p>在我司的混合式开发实践中，在页面加载阶段引入了 Jockey 做为 jsBridge 桥接桥梁，Jockey 的实现方式是通过请求特定 scheme 从而通知 Native 端，并在全局挂载事件，等待 Native 的触发，接下来我们将分析 Jockey 的源码，了解整个混合式开发底层原理。</p><h3 id="什么是-Jockey？"><a href="#什么是-Jockey？" class="headerlink" title="什么是 Jockey？"></a>什么是 Jockey？</h3><p><a href="https://github.com/tcoulter/jockeyjs">Jockeyjs</a>是一个连接 Native 与 H5 之间的 jsBridge，通过拦截请求的方式实现通讯。由于作者前端出身，所以对 Jockey 源码的讨论主要放在 JockeyJS 类上。</p><h3 id="Jockey-实现的-API"><a href="#Jockey-实现的-API" class="headerlink" title="Jockey 实现的 API"></a>Jockey 实现的 API</h3><p>Jockey 解决了端与 H5 的双向沟通问题，提供了四个主要的方法：</p><table><thead><tr><th>API</th><th>用途</th></tr></thead><tbody><tr><td>send</td><td>H5 调用,向 Native 发送事件请求</td></tr><tr><td>on</td><td>H5 调用，注册全局函数，以便 Native 主动触发</td></tr><tr><td>tigger</td><td>Native 调用，用于触发 JavaScript 注册的方法</td></tr><tr><td>triggerCallback</td><td>Native 调用，响应 H5 请求后，触发 H5 存储的回调函数</td></tr></tbody></table><p>接下来，我们便主要从这几个 API 入手，研究 jockey 源码。</p><h4 id="IIFE-执行挂载"><a href="#IIFE-执行挂载" class="headerlink" title="IIFE 执行挂载"></a>IIFE 执行挂载</h4><p>Jockey 源码主要由一个 IIFE 函数体组成，在进行了一些简单的环境判断后，将 Jockey 对象挂载至 window 下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Javascript">;(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> host = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">host</span>;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,<br>        iOS = <span class="hljs-literal">false</span>,<br>        iDevice = [<span class="hljs-string">&#x27;iPad&#x27;</span>, <span class="hljs-string">&#x27;iPhone&#x27;</span>, <span class="hljs-string">&#x27;iPod&#x27;</span>];<br><br>    <span class="hljs-keyword">for</span> (; i &lt; iDevice.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">platform</span>.<span class="hljs-title function_">indexOf</span>(iDevice[i]) &gt;= <span class="hljs-number">0</span>) &#123;<br>            iOS = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> <span class="hljs-title class_">UIWebView</span>  = <span class="hljs-regexp">/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i</span>.<span class="hljs-title function_">test</span>(navigator.<span class="hljs-property">userAgent</span>);<br>    <span class="hljs-keyword">var</span> isAndroid  = navigator.<span class="hljs-property">userAgent</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;android&quot;</span>) &gt; -<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 如果在 Native 环境中，将 Jockey.dispatchers 补充 nativeDispatcher 触发器</span><br>    <span class="hljs-keyword">if</span> ((iOS &amp;&amp; <span class="hljs-title class_">UIWebView</span>) || isAndroid) &#123;<br>        <span class="hljs-title class_">Jockey</span>.<span class="hljs-property">dispatchers</span>.<span class="hljs-title function_">push</span>(nativeDispatcher);<br>    &#125;<br><br>    <span class="hljs-title class_">Jockey</span>.<span class="hljs-property">dispatchers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">IframeDispatcher</span>);<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, $.<span class="hljs-title function_">proxy</span>(<span class="hljs-title class_">Jockey</span>.<span class="hljs-property">onMessageRecieved</span>, <span class="hljs-title class_">Jockey</span>), <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">Jockey</span> = <span class="hljs-title class_">Jockey</span>;<br></code></pre></td></tr></table></figure><p>在上面的函数中引用到了 Jockey、nativeDispatcher、IframeDispatcher 对象，这是为了更直观的阅读源码，因此抽离了大部分逻辑，接下来，我们将一个个分析这三个模块，理解整个 Jockey 的设计思路。</p><h4 id="nativeDispatcher"><a href="#nativeDispatcher" class="headerlink" title="nativeDispatcher"></a>nativeDispatcher</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> nativeDispatcher = &#123;<br>        <span class="hljs-comment">// 订阅回调函数映射</span><br>        <span class="hljs-attr">callbacks</span>: &#123;&#125;,<br>        <span class="hljs-comment">// H5调用该方法，实现向 Native 发送信息</span><br>        <span class="hljs-attr">send</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">envelope, complete</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatchMessage</span>(<span class="hljs-string">&quot;event&quot;</span>, envelope, complete);<br>        &#125;,<br><br>        <span class="hljs-comment">// 发送 callback 回调至 Native 用于 Native 触发完成后H5回调通知 Native</span><br>        <span class="hljs-attr">sendCallback</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">messageId</span>) &#123;<br>            <span class="hljs-keyword">var</span> envelope = <span class="hljs-title class_">Jockey</span>.<span class="hljs-title function_">createEnvelope</span>(messageId);<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatchMessage</span>(<span class="hljs-string">&quot;callback&quot;</span>, envelope, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;);<br>        &#125;,<br><br>        <span class="hljs-attr">triggerCallback</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) &#123;<br>            <span class="hljs-keyword">var</span> dispatcher = <span class="hljs-variable language_">this</span>;<br><br>            <span class="hljs-comment">// 加入 setTimeout 是为了避免 App 卡顿，将执行任务后置到下个时间片执行</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                dispatcher.<span class="hljs-property">callbacks</span>[id]();<br>            &#125;, <span class="hljs-number">0</span>);<br>        &#125;,<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * dispatchMessage 方法实际上是向 Native 发送消息的主要实践者</span><br><span class="hljs-comment">         * 通过拼接一个以 jockey为特殊scheme请求，使 Native 进行拦截，对参数进行解析。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-attr">dispatchMessage</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">type, envelope, complete</span>) &#123;<br><br>            <span class="hljs-keyword">var</span> dispatcher = <span class="hljs-variable language_">this</span>;<br>            <span class="hljs-comment">// 在执行发送任务前，将任务的回调函数存储，等待 Native 完成响应后，触发回调依次执行。</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[envelope.<span class="hljs-property">id</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title function_">complete</span>();<br><br>                <span class="hljs-keyword">delete</span> dispatcher.<span class="hljs-property">callbacks</span>[envelope.<span class="hljs-property">id</span>];<br>            &#125;;<br>          <span class="hljs-comment">// 拼接传递参数，通过创建 Iframe 实现发送请求，请求发送完毕后移除 iframe</span><br>          <span class="hljs-keyword">var</span> src = <span class="hljs-string">&quot;jockey://&quot;</span> + type + <span class="hljs-string">&quot;/&quot;</span> + envelope.<span class="hljs-property">id</span> + <span class="hljs-string">&quot;?&quot;</span> + <span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(envelope));<br>            <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;iframe&quot;</span>);<br>            iframe.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;src&quot;</span>, src);<br>            <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">appendChild</span>(iframe);<br>            iframe.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(iframe);<br>            iframe = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;;<br></code></pre></td></tr></table></figure><h4 id="IframeDispatcher"><a href="#IframeDispatcher" class="headerlink" title="IframeDispatcher"></a>IframeDispatcher</h4><p>IframeDispatcher 存在的意义是保证在非 Native 环境下，Jockeyjs 依旧可以保持正常运转。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">IframeDispatcher</span> = &#123;<br>  <span class="hljs-attr">callbacks</span>: &#123;&#125;,<br><br>  <span class="hljs-attr">send</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">envelope, complete</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatchMessage</span>(<span class="hljs-string">&quot;jockeyEvent&quot;</span>, envelope, complete);<br>  &#125;,<br><br>  <span class="hljs-attr">sendCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">messageId</span>) &#123;<br>    <span class="hljs-keyword">var</span> envelope = <span class="hljs-title class_">Jockey</span>.<span class="hljs-title function_">createEnvelope</span>(messageId);<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatchMessage</span>(<span class="hljs-string">&quot;jockeyCallback&quot;</span>, envelope, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;);<br>  &#125;,<br><br>  <span class="hljs-attr">triggerCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[id]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[id]();<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-attr">dispatchMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">type, envelope, complete</span>) &#123;<br>    <span class="hljs-keyword">var</span> dispatcher = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[envelope.<span class="hljs-property">id</span>] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">complete</span>();<br><br>      <span class="hljs-keyword">delete</span> dispatcher.<span class="hljs-property">callbacks</span>[envelope.<span class="hljs-property">id</span>];<br>    &#125;;<br><br>    <span class="hljs-title class_">Jockey</span>.<span class="hljs-property">targetWindow</span>.<span class="hljs-title function_">postMessage</span>(<br>      &#123; <span class="hljs-attr">type</span>: type, <span class="hljs-attr">envelope</span>: envelope &#125;,<br>      <span class="hljs-title class_">Jockey</span>.<span class="hljs-property">targetDomain</span><br>    );<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Jockey"><a href="#Jockey" class="headerlink" title="Jockey"></a>Jockey</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs Javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Jockey</span> = &#123;<br>  <span class="hljs-attr">listeners</span>: &#123;&#125;,<br>  <span class="hljs-comment">// 用于存放不同的触发器</span><br>  <span class="hljs-attr">dispatchers</span>: [],<br>  <span class="hljs-comment">// message 偏移 用于标识事件唯一 id</span><br>  <span class="hljs-attr">messageCount</span>: <span class="hljs-number">0</span>,<br><br>  <span class="hljs-attr">targetDomain</span>: <span class="hljs-string">&quot;*&quot;</span>,<br><br>  <span class="hljs-attr">targetWindow</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Jockey.on 实际的监听方法</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">on</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">type, fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<br>      !<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">hasOwnProperty</span>(type) ||<br>      !<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>[type] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br>    ) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>[type] = [];<br>    &#125;<br>    <span class="hljs-comment">// 注册监听函数</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>[type].<span class="hljs-title function_">push</span>(fn);<br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Jockey.on 实际的移除监听方法</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">off</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<br>      !<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>.<span class="hljs-title function_">hasOwnProperty</span>(type) ||<br>      !<span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>[type] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br>    ) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>[type] = [];<br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>[type] = [];<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Jockey.send H5向 Native 发送请求</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">send</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">type, payload, complete</span>) &#123;<br>    <span class="hljs-comment">//   参数处理</span><br>    <span class="hljs-keyword">if</span> (payload <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>) &#123;<br>      complete = payload;<br>      payload = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    payload = payload || &#123;&#125;;<br>    complete = complete || <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;;<br><br>    <span class="hljs-comment">// 创建一个包装事件</span><br>    <span class="hljs-keyword">var</span> envelope = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createEnvelope</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">messageCount</span>, type, payload);<br>    <span class="hljs-comment">// 调用不同环境的触发器，send 事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatchers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">dispatcher</span>) &#123;<br>      dispatcher.<span class="hljs-title function_">send</span>(envelope, complete);<br>    &#125;);<br>    <span class="hljs-comment">// 增加偏移，保证 id 不同</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageCount</span> += <span class="hljs-number">1</span>;<br>  &#125;,<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Native 通过调用该方法 向 H5发送消息</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">trigger</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">type, messageId, json</span>) &#123;<br>    <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-comment">// 获取 H5 通过 Jockey.on 注册的事件监听</span><br>    <span class="hljs-keyword">var</span> listenerList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">listeners</span>[type] || [];<br><br>    <span class="hljs-keyword">var</span> executedCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// H5在 Native tigger 后通知 Native 我方已完成回调函数的执行</span><br>    <span class="hljs-keyword">var</span> complete = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      executedCount += <span class="hljs-number">1</span>;<br><br>      <span class="hljs-keyword">if</span> (executedCount &gt;= listenerList.<span class="hljs-property">length</span>) &#123;<br>        self.<span class="hljs-property">dispatchers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">dispatcher</span>) &#123;<br>          dispatcher.<span class="hljs-title function_">sendCallback</span>(messageId);<br>        &#125;);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>; index &lt; listenerList.<span class="hljs-property">length</span>; index++) &#123;<br>      <span class="hljs-keyword">var</span> listener = listenerList[index];<br><br>      <span class="hljs-comment">// 检查当前监听函数参数，如果为一个，则直接触发complete回调</span><br>      <span class="hljs-comment">// 如果为两个 则手动触发回调</span><br>      <span class="hljs-keyword">if</span> (listener.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-title function_">listener</span>(json);<br>        <span class="hljs-title function_">complete</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">listener</span>(json, complete);<br>      &#125;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * H5经过 Native触发，完成响应后通知 Native</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-attr">triggerCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatchers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">dispatcher</span>) &#123;<br>      dispatcher.<span class="hljs-title function_">triggerCallback</span>(id);<br>    &#125;);<br>  &#125;,<br><br>  <span class="hljs-attr">restrictIframeDispatcher</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">targetDomain, targetWindow</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetDomain</span> = targetDomain;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetWindow</span> = targetWindow;<br>  &#125;,<br><br>  <span class="hljs-attr">onMessageRecieved</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">targetDomain</span> != <span class="hljs-string">&quot;*&quot;</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">targetDomain</span> != event.<span class="hljs-property">origin</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> envelope = event.<span class="hljs-property">data</span>.<span class="hljs-property">envelope</span>;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> == <span class="hljs-string">&quot;jockeyEvent&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">trigger</span>(envelope.<span class="hljs-property">type</span>, envelope.<span class="hljs-property">id</span>, envelope.<span class="hljs-property">payload</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> == <span class="hljs-string">&quot;jockeyCallback&quot;</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">triggerCallback</span>(event.<span class="hljs-property">data</span>.<span class="hljs-property">envelope</span>.<span class="hljs-property">id</span>);<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成事件单元</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">createEnvelope</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">id, type, payload</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">id</span>: id,<br>      <span class="hljs-attr">type</span>: type,<br>      <span class="hljs-attr">host</span>: host,<br>      <span class="hljs-attr">payload</span>: payload,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在分析 JockeyJs 源码后，我们可以总结一下通过拦截请求方式实现的 Jsbridge 的流程：</p><ul><li>H5 通知 Native<br>通过 <strong>Jockey.send</strong> 方法，创建 iframe,发送特定请求。如果有回调函数，则根据 id 存储至 callbacks 回调对象中，等待 Native 接收后触发 <strong>triggerCallback</strong> 方法依次执行回调函数。</li><li>Native 通知 H5<br>首先，H5 需要通过 <strong>Jockey.on</strong> 手动在 Jokey 全局上绑定监听事件。待 Native 需要通知时，在获取 JavaScript 运行时后，调用挂载在全局的 <strong>Jockey.tigger</strong> 方法，触发之前绑定的监听对象,待事件执行完成后，通过调用 <strong>sendCallback</strong> 方法通知至 Native。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>源码解析</tag>
      
      <tag>Hybrid</tag>
      
      <tag>JockeyJS</tag>
      
      <tag>混合式开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise/A+规范翻译</title>
    <link href="/2021/01/05/Promise-A-%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/"/>
    <url>/2021/01/05/Promise-A-%E8%A7%84%E8%8C%83%E7%BF%BB%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Promise 是我们在日常开发中必不可少的 API。Promise 的出现，解决了臭名昭著的回调地狱异步编程模式。Promise 作为一个存储着异步调用函数的容器，通过使用 then、catch 等方法注册回调完成后执行的事件，极大程度上优化了异步开发体验。现如今的 Promise 规范中，主要是在 Promise&#x2F;A+规范之上，扩展了 all、race、allSettled 等方法，因此了解 Promise&#x2F;A+规范，有利于我们知悉 Promise 的底层执行过程。</p><h2 id="Promise-x2F-A-规范翻译"><a href="#Promise-x2F-A-规范翻译" class="headerlink" title="Promise&#x2F;A+ 规范翻译"></a>Promise&#x2F;A+ 规范翻译</h2><h3 id="1-状态"><a href="#1-状态" class="headerlink" title="1. 状态"></a>1. 状态</h3><p>Promise 必须是以下三种状态之一： Pending, Fulfilled, Rejected</p><ul><li>Promise 处于 Pending 状态下，可以转化为 Fulfilled 或者 Rejected。</li><li>如果 Promise 已处于 Fulfilled 或者 Rejected 状态，则无法继续进行状态转移。此时 Fulfilled 对应的 value、 Rejected 对应的 reason 不可变化。</li></ul><h3 id="2-then-Promise-then-onFulfilled-onRejected"><a href="#2-then-Promise-then-onFulfilled-onRejected" class="headerlink" title="2. then Promise.then(onFulfilled, onRejected)"></a>2. then Promise.then(onFulfilled, onRejected)</h3><p>Promise 必须提供一个 then 方法作为执行或者订阅异步函数完成后执行的操作</p><ul><li>onFulfilled 与 onRejected 为可选参数。onFulfilled 与 onRejected 仅可被做为函数调用，如果未传入或者传入值类型非函数类型，则忽略。</li><li>onFulfilled 为函数，则 onFulfilled 必须在 Promise 状态转移至 Fulfilled 状态后被调用，且将接收到 value 作为函数唯一入参。</li><li>onRejected 为函数，则 onRejected 必须在 Promise 状态转移至 Rejected 状态后被调用，且将接受到 reason 作为参数唯一入参。</li><li>onFulfilled 与 onRejected 仅能被调用一次。</li><li>then 方法可以被一个 Promise 多次调用，当 Promise 状态发生变更后，所有的 onFulfilled 和 onRejected 必须按照注册顺序依次执行。</li><li>then 方法必须返回一个新的 Promise，以支持链式调用。<ul><li>i: onFulfilled 或者 onRejected 返回一个值 x ，则运行 Promise 解决过程：[[Resolve]](promise2, x);</li><li>ii: 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e;</li><li>iii: 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的 value;</li><li>iv: 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的 reason;</li></ul></li></ul><h2 id="Promise-的执行过程"><a href="#Promise-的执行过程" class="headerlink" title="Promise 的执行过程"></a>Promise 的执行过程</h2><p>Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise。</p><ul><li>如果 promise 与 x 为同一个值，则以 TypeError 异常作为 reason 拒绝 promise。</li><li>如果 x 为 Promise 态，即 x instanceof Promise，则使 promise 接收 x 的状态：<ul><li>如果 x 处于 Pedding 态， promise 需保持为等待态直至 x 被执行或拒绝</li><li>如果 x 处于 Fulfilled 状态，用相同的 value 执行 promise</li><li>如果 x 处于 Reject 状态，用相同的 reason 拒绝 promise</li></ul></li><li>如果 x 为对象或者函数<ul><li>把 x.then 赋值给 then</li><li>如果取 x.then 的值时抛出错误 e ，则以 e 为 reason 拒绝 promise</li><li>如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise</li><li>如果 resolvePromise 以 y 为参数被调用，则运行 [[Resolve]](promise, y)</li><li>如果 rejectPromise 以 r 为参数被调用，则以 reason r 拒绝 promise</li><li>如果 resolvePromise 和 rejectPromise 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li><li>如果调用 then 方法抛出了异常 e: 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之;否则以 e 为 reason 拒绝 promise;</li><li>如果 then 不是函数，以 x 为参数执行 promise</li><li>如果 x 不为对象或者函数，则以 x 为参数执行 Promise;</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
